= Julia RDF Ecosystem Research
:author: Research for Anamnesis Project
:date: 2025-11-22
:toc: left
:toclevels: 3
:sectnums:
:source-highlighter: pygments
:icons: font

[abstract]
== Abstract

Comprehensive research into the Julia programming language ecosystem for RDF (Resource Description Framework) manipulation, SPARQL querying, and integration with Virtuoso triple store for the Anamnesis conversation knowledge extraction system. This research adheres to the project constraint of NO PYTHON libraries.

== Executive Summary

The Julia RDF ecosystem is **limited but functional**, with several small, focused packages maintained primarily by Evan Patterson (epatters). The ecosystem lacks the maturity and breadth of Python's RDFLib or Java's Apache Jena, but provides sufficient capability for basic RDF operations and SPARQL integration with Virtuoso.

**Key Finding**: The most promising approach for Anamnesis is to use **Serd.jl** for RDF serialization/deserialization combined with **HTTP.jl** for direct SPARQL endpoint communication with Virtuoso.

**Critical Discovery**: The packages commonly assumed to exist‚Äî**Semantic.jl** and **RDFLib.jl**‚Äîdo not exist as RDF libraries in the Julia ecosystem. This report clarifies the actual available packages.

== Terminology Clarification

=== Non-Existent Packages

WARNING: The following packages **DO NOT EXIST** as RDF libraries:

[cols="1,3"]
|===
|Package Name |What Actually Exists

|Semantic.jl
|Does not exist. **SemanticModels.jl** exists but is for scientific model semantics, not RDF.

|RDFLib.jl
|Does not exist. **RDFLib** is a Python library. Julia has **RDF.jl** instead.
|===

== Julia RDF Libraries

=== 1. RDF.jl

==== Overview

RDF.jl is a Julia package for working with RDF graphs, supporting common serialization formats.

[cols="1,3"]
|===
|Repository |https://github.com/JuliaPackageMirrors/RDF.jl (mirror)
|Status |‚ö†Ô∏è Uncertain - appears to be a package mirror, original repo unclear
|Maintenance |‚ùå Not actively maintained (no recent updates found)
|License |Unknown
|Language |100% Julia
|===

==== Capabilities

* RDF graph manipulation
* Serialization formats supported:
** N-Triples
** N-Quads
** Turtle

==== Limitations

* Limited documentation available
* Uncertain maintenance status
* No clear primary repository or active development
* No performance benchmarks published
* Package mirror suggests possible deprecation

==== Maturity Assessment

[WARNING]
====
**Status: QUESTIONABLE**

RDF.jl appears to be an older package with uncertain maintenance. The only available repository is a "package mirror," suggesting the original may be deprecated or abandoned. Not recommended for production use without further investigation.
====

==== Example Usage

[source,julia]
----
# No reliable examples found in available documentation
# Repository lacks comprehensive README
----

=== 2. Serd.jl ‚≠ê RECOMMENDED

==== Overview

Serd.jl provides Julia bindings to Serd, a lightweight C library for RDF serialization optimized for performance and resource-constrained environments.

[cols="1,3"]
|===
|Repository |https://github.com/epatters/Serd.jl
|Author |Evan Patterson (epatters)
|Status |‚úÖ Active (last update: September 2023)
|Stars |10 ‚≠ê
|Forks |5
|Commits |46
|License |MIT
|Language |100% Julia
|CI/CD |‚úÖ Passing tests
|===

==== Capabilities

* **High-level interface**: Main `Serd` module for reading/writing RDF
* **Low-level interface**: `Serd.CSerd` submodule for direct C library access
* Serialization formats supported:
** Turtle
** TriG
** N-Triples
** N-Quads

==== Performance Characteristics

From Serd C library documentation:

* Designed for **performance-critical applications**
* Suitable for **resource-limited environments**
* Optimized for **serializing very large datasets**
* Ideal for **embedded systems**

NOTE: Serd is specifically noted as suitable for performance-critical applications, making it ideal for processing large conversation datasets in Anamnesis.

==== Type Safety

* Uses Julia's type system
* C bindings provide low-level type safety through Julia's `ccall` mechanism
* Dual-interface design allows type-safe high-level usage while maintaining C library performance

==== Example Usage

[source,julia]
----
using Serd

# High-level interface for reading RDF
# (Specific examples not provided in README, would need to consult source)

# Low-level interface for advanced use cases
using Serd.CSerd
# Direct C library access for performance-critical operations
----

==== Maturity Assessment

[NOTE]
====
**Status: PRODUCTION-READY**

Well-maintained by a known contributor to the Julia semantic web ecosystem. Built on battle-tested Serd C library. Suitable for production use in Anamnesis.
====

==== Integration with SPARQL.jl

The SPARQL.jl package explicitly recommends Serd.jl for RDF I/O operations, indicating ecosystem coherence.

=== 3. SPARQL.jl

==== Overview

SPARQL.jl is a SPARQL query generator for programmatically constructing queries in Julia.

[cols="1,3"]
|===
|Repository |https://github.com/epatters/SPARQL.jl
|Author |Evan Patterson (epatters)
|Status |‚úÖ Active
|Stars |7 ‚≠ê
|Forks |2
|Commits |15
|Releases |‚ùå None published
|License |MIT
|Language |100% Julia
|===

==== Capabilities

* Programmatic SPARQL query generation
* Type-safe query construction in Julia

==== Limitations

[IMPORTANT]
====
**Does NOT support parsing SPARQL queries** - only generation.

For executing queries against endpoints, use HTTP.jl directly (see <<SPARQL Endpoint Integration>>).
====

==== Example Usage

[source,julia]
----
# Note: Specific examples not provided in README
# Package generates SPARQL query strings programmatically
# Recommended to consult source code for usage patterns
----

==== Maturity Assessment

[CAUTION]
====
**Status: EXPERIMENTAL**

No releases published. Limited documentation. Suitable for query construction but requires HTTP.jl for execution.
====

== SPARQL Support in Julia

=== SPARQL Endpoint Integration

Julia can query SPARQL endpoints using standard HTTP libraries.

==== HTTP.jl Approach ‚≠ê RECOMMENDED

[source,julia]
----
using HTTP

# Basic SPARQL query via HTTP POST
sparql_query = """
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
SELECT ?subject ?predicate ?object
WHERE {
  ?subject ?predicate ?object
}
LIMIT 10
"""

endpoint = "http://localhost:8890/sparql"

response = HTTP.post(
    endpoint,
    ["Content-Type" => "application/sparql-query",
     "Accept" => "application/sparql-results+json"],
    sparql_query;
    redirect_method="POST"  # Important: preserve POST on redirect
)

# Parse JSON response
using JSON
results = JSON.parse(String(response.body))
----

==== Critical Implementation Detail

[WARNING]
====
**HTTP Redirect Handling**

Some SPARQL endpoints (e.g., UK Open Geography Portal) use HTTP 301 redirects improperly, causing HTTP.jl to convert POST to GET and lose query data.

**Solution**: Always use `redirect_method="POST"` parameter.
====

==== SPARQL Protocol Compliance

Julia's HTTP.jl fully supports SPARQL 1.1 Protocol:

* Query via GET or POST
* Update via POST
* Content negotiation
* Result formats: JSON, XML, CSV, TSV
* Authentication headers

=== Comparison to Python's SPARQLWrapper

[cols="1,2,2"]
|===
|Feature |Python SPARQLWrapper |Julia HTTP.jl Approach

|Abstraction Level
|High-level wrapper
|Lower-level HTTP client

|Query Execution
|Built-in methods
|Manual HTTP requests

|Result Parsing
|Automatic conversion
|Manual JSON/XML parsing

|DataFrame Integration
|Direct Pandas support
|Requires DataFrames.jl integration

|Maturity
|Production-ready
|Functional but requires more code

|Type Safety
|Runtime types (Python)
|Compile-time types (Julia)
|===

== Virtuoso Integration

=== Connection Methods

Virtuoso triple store can be accessed from Julia via two primary methods:

==== 1. SPARQL Endpoint (HTTP) ‚≠ê RECOMMENDED

[source,julia]
----
using HTTP
using JSON

# Connect to Virtuoso SPARQL endpoint
virtuoso_endpoint = "http://localhost:8890/sparql"

function query_virtuoso(query::String)
    response = HTTP.post(
        virtuoso_endpoint,
        ["Content-Type" => "application/sparql-query",
         "Accept" => "application/sparql-results+json"],
        query;
        redirect_method="POST"
    )
    return JSON.parse(String(response.body))
end

# Example query
results = query_virtuoso("""
PREFIX dc: <http://purl.org/dc/elements/1.1/>
SELECT ?title WHERE { ?x dc:title ?title } LIMIT 5
""")
----

===== Advantages

* ‚úÖ Standard SPARQL 1.1 Protocol
* ‚úÖ No additional drivers required
* ‚úÖ Works with any SPARQL-compliant endpoint
* ‚úÖ JSON/XML result formats
* ‚úÖ Simple deployment

===== Disadvantages

* ‚ùå HTTP overhead for large result sets
* ‚ùå Manual result parsing required
* ‚ùå No streaming for large queries

==== 2. ODBC Connection

[source,julia]
----
using ODBC
using DBInterface

# Configure Virtuoso ODBC connection
# Requires Virtuoso ODBC driver installed on system

conn = ODBC.Connection(
    "Driver={OpenLink Virtuoso};Host=localhost;Port=1111;UID=dba;PWD=dba;Database=DB"
)

# Execute SPARQL via ODBC
query = "SPARQL SELECT * WHERE { ?s ?p ?o } LIMIT 10"
result = DBInterface.execute(conn, query)

# Process results
for row in result
    println(row)
end

DBInterface.close!(conn)
----

===== Connection Parameters

[cols="1,3"]
|===
|Parameter |Description

|Driver
|`OpenLink Virtuoso` (must be installed)

|Host
|Virtuoso server hostname

|Port
|Default: 1111 (SQL port, NOT 8890 SPARQL port)

|UID
|Database user (default: `dba`)

|PWD
|Database password

|Database
|Qualifier/catalog (default: `DB`)

|DSN
|Alternative: Data Source Name if configured
|===

===== Advantages

* ‚úÖ Native database connection
* ‚úÖ Potential performance benefits for large queries
* ‚úÖ Transactional support
* ‚úÖ Streaming results

===== Disadvantages

* ‚ùå Requires ODBC driver installation
* ‚ùå Platform-specific configuration
* ‚ùå Additional system dependencies
* ‚ùå More complex deployment

=== Recommendation for Anamnesis

[TIP]
====
**Use HTTP/SPARQL Endpoint Approach**

For Anamnesis, the HTTP-based SPARQL endpoint is recommended:

1. Simpler deployment (no driver dependencies)
2. Standard protocol (portable)
3. Sufficient performance for conversation data
4. Easier debugging and monitoring
5. Works with any SPARQL endpoint (not Virtuoso-specific)

Reserve ODBC for future optimization if performance profiling identifies HTTP as a bottleneck.
====

== Performance Considerations

=== Available Benchmarks

[WARNING]
====
**Limited Julia-Specific Benchmarks**

No comprehensive performance benchmarks were found comparing Julia RDF libraries to Python/Java equivalents.
====

=== General RDF Parsing Performance

From general RDF community benchmarks:

[cols="1,3"]
|===
|Format |Parsing Characteristics

|N-Triples
|‚ö° **Fastest** - Simple line-based format, trivial parsing

|N-Quads
|‚ö° Fast - Similar to N-Triples with context

|Turtle
|‚è±Ô∏è Moderate - Requires full parser, more compact

|RDF/XML
|üêå Slowest - Complex XML parsing overhead

|TriG
|‚è±Ô∏è Moderate - Turtle with named graphs
|===

=== Serd C Library Performance

From Serd documentation:

* Optimized for **very large datasets**
* **Streaming parser** - constant memory usage
* Designed for **embedded systems** - minimal resource footprint
* Used in production semantic web applications

=== Recommendations for Anamnesis

1. **Use N-Triples or N-Quads** for bulk data exchange with Virtuoso
   * Fastest parsing
   * Simple format
   * Easy to generate from conversation data

2. **Use Turtle** for human-readable exports
   * More compact
   * Better readability
   * Namespace prefix support

3. **Profile before optimizing** - Julia's JIT compilation may provide good performance even without specific optimization

== Type Safety and Julia Integration

=== Julia Type System Benefits

Julia's type system provides significant advantages for RDF work:

==== Strong Static Typing (Optional)

[source,julia]
----
# Define typed RDF structures
struct Triple
    subject::String
    predicate::String
    object::Union{String, Int64, Float64}
end

# Type-safe triple creation
function create_triple(s::String, p::String, o)::Triple
    return Triple(s, p, o)
end

# Compiler catches type errors
triple = create_triple("http://example.org/subject",
                       "http://example.org/predicate",
                       "value")
----

==== Multiple Dispatch

[source,julia]
----
# Define different serialization methods based on type
serialize(t::Triple, ::Type{NTriples}) = "$(t.subject) $(t.predicate) $(t.object) ."
serialize(t::Triple, ::Type{Turtle}) = "... turtle format ..."

# Dispatch automatically selects correct method
output = serialize(triple, NTriples)
----

==== Integration with Serd.jl

Serd.jl leverages Julia's C FFI (`ccall`) for type-safe bindings:

* C types mapped to Julia types
* Memory management handled by Julia GC
* Zero-copy operations where possible
* Type conversions validated at compile time

=== Comparison to Python

[cols="1,2,2"]
|===
|Aspect |Python RDFLib |Julia Serd.jl

|Type Checking
|Runtime (optional mypy)
|Compile-time (optional)

|Performance
|Interpreted baseline
|JIT-compiled to native

|Memory Safety
|GC only
|GC + RAII patterns

|C Integration
|ctypes/CFFI (manual)
|ccall (integrated)

|Multiple Dispatch
|Single dispatch
|Full multiple dispatch
|===

== Alternative Approaches

Beyond traditional RDF libraries, Julia offers innovative alternatives for knowledge representation.

=== Catlab.jl / AlgebraicJulia Ecosystem ‚≠ê INNOVATIVE

==== Overview

Catlab.jl is a framework for applied category theory developed by Evan Patterson (same author as Serd.jl and SPARQL.jl).

[cols="1,3"]
|===
|Project |https://www.algebraicjulia.org/
|Repository |https://github.com/AlgebraicJulia/Catlab.jl
|Paradigm |Category theory, compositional semantics
|Status |‚úÖ Active development (2024-2025)
|Community |Academic + industrial collaboration
|===

==== Relevance to Knowledge Representation

Recent work by Evan Patterson demonstrates direct application to knowledge graphs:

===== Double-Functorial Semantics (2024)

*Paper*: "Representing Knowledge and Querying Data using Double-Functorial Semantics" (Michael Lambert & Evan Patterson, 2024)

**Key Ideas**:

* Category theory provides mathematical foundation for knowledge representation
* Double categories of relations express knowledge flexibly
* Queries captured by double-functorial semantics
* Alternative to traditional RDF triple store approach

===== ACSets (Algebraic C-Sets)

**Concept**: "Categorical data structures for technical computing"

* In-memory data structures based on category theory
* Type-safe knowledge representation
* Query operations through categorical constructs
* Published in *Compositionality* 4, 5 (2022)

==== Comparison to RDF Approach

[cols="1,2,2"]
|===
|Aspect |Traditional RDF |Catlab.jl Approach

|Theoretical Foundation
|Set theory, logic
|Category theory

|Data Model
|Subject-Predicate-Object triples
|C-sets, double categories

|Query Language
|SPARQL
|Double-functorial semantics

|Reasoning
|OWL, RDFS, rules
|Categorical constructions

|Maturity
|Decades of tooling
|Cutting-edge research

|Ecosystem
|Broad (many languages)
|Narrow (Julia-specific)

|Type Safety
|Varies by implementation
|Built-in via Julia types

|Academic Rigor
|Strong (W3C standards)
|Strong (category theory)
|===

==== Recommendation for Anamnesis

[NOTE]
====
**Consider Hybrid Approach**

Given Anamnesis's academic rigor requirement and Evan Patterson's expertise in both RDF (Serd.jl/SPARQL.jl) *and* category theory (Catlab.jl), consider:

1. **Phase 1**: Use Serd.jl + Virtuoso (proven technology)
2. **Phase 2**: Explore Catlab.jl for reasoning layer
3. **Integration**: RDF for storage, categories for computation

This aligns with the "academic rigor" requirement while maintaining practical near-term deliverables.
====

=== SemanticModels.jl

==== Overview

[cols="1,3"]
|===
|Repository |https://github.com/jpfairbanks/SemanticModels.jl
|Purpose |Model semantics, not RDF
|Relevant Feature |Knowledge graph extraction from Julia code
|===

==== Capabilities

* Extracts semantic information from scientific models
* Builds knowledge graphs from code structure
* Dynamic type analysis for graph construction
* Nodes = types, Edges = functions

==== Relevance to Anamnesis

Limited direct relevance - focused on scientific model semantics rather than conversation knowledge extraction. However, techniques for extracting semantic graphs from code could inspire conversation parsing strategies.

=== TypeDBClient.jl

==== Overview

[cols="1,3"]
|===
|Repository |https://github.com/Humans-of-Julia/TypeDBClient.jl
|Purpose |Client for TypeDB knowledge graph database
|Status |‚úÖ Active (v0.1.2, March 2022)
|Stars |51 ‚≠ê
|Commits |434
|Contributors |7
|License |MIT
|===

==== TypeDB vs Virtuoso

[cols="1,2,2"]
|===
|Aspect |Virtuoso (RDF) |TypeDB

|Data Model
|RDF triples
|Entity-Relation-Attribute

|Query Language
|SPARQL
|TypeQL (graph query language)

|Standards Compliance
|W3C RDF, SPARQL
|Proprietary (open source)

|Reasoning
|RDFS, OWL (optional)
|Built-in automated reasoning

|Schema
|Optional (RDFS/OWL)
|Required (strict typing)

|Distribution
|Yes
|Yes (partitioning, replication)

|Maturity
|Decades (production-grade)
|Newer (production-grade)
|===

==== Recommendation for Anamnesis

[CAUTION]
====
**Not Recommended for Initial Implementation**

While TypeDB offers interesting capabilities, choosing it would:

* ‚ùå Deviate from established Virtuoso requirement
* ‚ùå Require learning TypeQL vs standard SPARQL
* ‚ùå Reduce ecosystem compatibility
* ‚ùå Limit future integration options

However, TypeDB's reasoning capabilities could be relevant for later phases if automated inference becomes critical.
====

== Comprehensive Comparison Matrix

=== Julia RDF Libraries Comparison

[cols="1,1,1,1,1,1"]
|===
|Library |Status |Formats |SPARQL |Performance |Recommendation

|RDF.jl
|‚ùå Uncertain
|N-Triples, N-Quads, Turtle
|‚ùå No
|‚ùì Unknown
|‚ùå Avoid

|Serd.jl
|‚úÖ Active
|Turtle, TriG, N-Triples, N-Quads
|Via SPARQL.jl
|‚ö° High (C library)
|‚úÖ **RECOMMENDED**

|SPARQL.jl
|‚ö†Ô∏è Experimental
|N/A (query generation)
|‚úÖ Generation only
|N/A
|‚ö†Ô∏è Optional

|HTTP.jl
|‚úÖ Production
|N/A (protocol)
|‚úÖ Endpoint queries
|‚ö° Standard HTTP
|‚úÖ **RECOMMENDED**

|ODBC.jl
|‚úÖ Production
|N/A (database)
|‚úÖ Via Virtuoso
|‚ö° Native DB
|‚ö†Ô∏è Optional
|===

=== Virtuoso Integration Comparison

[cols="1,2,2,2"]
|===
|Method |Complexity |Performance |Recommendation

|HTTP/SPARQL
|Low (no drivers)
|Good (HTTP overhead)
|‚úÖ **Primary approach**

|ODBC
|High (driver setup)
|Better (native connection)
|‚ö†Ô∏è Optimize later if needed

|JDBC
|High (JVM required)
|Better (native connection)
|‚ùå Avoid (JVM dependency)
|===

== Recommendations for Anamnesis

=== Recommended Technology Stack

[source,yaml]
----
RDF Serialization:
  - Primary: Serd.jl
  - Formats: N-Triples (bulk), Turtle (readable)

SPARQL Execution:
  - Primary: HTTP.jl (direct endpoint access)
  - Optional: SPARQL.jl (query generation)

Virtuoso Integration:
  - Phase 1: HTTP SPARQL endpoint
  - Phase 2: ODBC.jl if performance requires

Type Safety:
  - Julia native type system
  - Custom structs for domain models
  - Multiple dispatch for operations
----

=== Implementation Roadmap

==== Milestone 1: Basic RDF Pipeline

**Goal**: Parse single Claude conversation JSON ‚Üí Virtuoso RDF triples

**Components**:

1. Install Serd.jl for RDF serialization
2. Generate N-Triples from conversation data
3. Upload to Virtuoso via HTTP.jl
4. Verify with SPARQL query

**Code Skeleton**:

[source,julia]
----
using Serd
using HTTP
using JSON

# 1. Parse conversation JSON
conversation = JSON.parsefile("claude_conversation.json")

# 2. Convert to RDF triples (N-Triples format)
function conversation_to_ntriples(conv)::Vector{String}
    triples = String[]
    # Extract subject, predicate, object from conversation
    # Generate N-Triples format strings
    return triples
end

triples = conversation_to_ntriples(conversation)

# 3. Write to file or string
ntriples_data = join(triples, "\n")

# 4. Upload to Virtuoso via HTTP
virtuoso_upload_endpoint = "http://localhost:8890/sparql-graph-crud-auth"
graph_uri = "http://anamnesis.example.org/conversations/001"

response = HTTP.post(
    virtuoso_upload_endpoint,
    ["Content-Type" => "application/n-triples"],
    ntriples_data;
    query=Dict("graph-uri" => graph_uri)
)

# 5. Verify with SPARQL query
query = """
SELECT ?s ?p ?o
FROM <$graph_uri>
WHERE { ?s ?p ?o }
LIMIT 10
"""

results = HTTP.post(
    "http://localhost:8890/sparql",
    ["Content-Type" => "application/sparql-query",
     "Accept" => "application/sparql-results+json"],
    query
)

println(String(results.body))
----

==== Milestone 2: Multi-LLM Support

**Extensions**:

* Source attribution in RDF (provenance ontology)
* Conversation metadata (date, LLM model, etc.)
* Cross-conversation linking

==== Milestone 3: Advanced Reasoning (Optional)

**Explore**:

* Catlab.jl integration for meta-reasoning
* ŒªProlog reasoning over RDF-extracted knowledge
* Hybrid RDF + categorical approach

=== Package Installation

[source,julia]
----
# Install recommended packages
using Pkg

Pkg.add("Serd")        # RDF serialization
Pkg.add("HTTP")        # SPARQL endpoint access
Pkg.add("JSON")        # JSON parsing
Pkg.add("DataFrames")  # Optional: for result tables

# Optional packages
Pkg.add("SPARQL")      # Query generation
Pkg.add("ODBC")        # Native DB access (if needed later)
----

=== Configuration

[source,julia]
----
# config.jl - Anamnesis configuration

const VIRTUOSO_SPARQL_ENDPOINT = "http://localhost:8890/sparql"
const VIRTUOSO_UPLOAD_ENDPOINT = "http://localhost:8890/sparql-graph-crud-auth"
const VIRTUOSO_USER = "dba"
const VIRTUOSO_PASSWORD = "dba"

const RDF_FORMAT = :ntriples  # :ntriples, :turtle, :nquads
const BASE_GRAPH_URI = "http://anamnesis.example.org"
----

== Gaps and Limitations

=== Current Ecosystem Gaps

[WARNING]
====
**Julia RDF Ecosystem Limitations**

The Julia RDF ecosystem is significantly less mature than Python or Java:

* ‚ùå No comprehensive RDF library (like RDFLib or Jena)
* ‚ùå No built-in SPARQL result ‚Üí DataFrame conversion
* ‚ùå Limited OWL/RDFS reasoning support
* ‚ùå No visual query builders or development tools
* ‚ùå Sparse documentation and examples
* ‚ùå Small community (fewer StackOverflow answers)
====

=== Workarounds

[cols="1,2"]
|===
|Gap |Workaround

|No RDFLib equivalent
|Use Serd.jl + HTTP.jl combination

|No DataFrame integration
|Manual JSON parsing + DataFrames.jl construction

|No reasoning
|Use Virtuoso's built-in reasoning or external reasoner

|Limited docs
|Study source code, contact epatters, community forums

|Small community
|Leverage Julia Discourse, direct package maintainer contact
|===

=== Future Improvements Needed

Community contributions that would benefit the ecosystem:

1. **Comprehensive RDF.jl rewrite** - Modern, maintained, documented
2. **SPARQL result parsers** - Automatic DataFrame conversion
3. **RDF validation** - SHACL/ShEx support
4. **OWL reasoning** - Julia-native reasoner
5. **Triple store abstraction** - Unified interface for Virtuoso/Blazegraph/etc.
6. **Benchmarks** - Performance comparisons with Python/Java

== Conclusion

=== Summary of Findings

The Julia RDF ecosystem is **functional but minimal**, centered around Evan Patterson's packages:

1. **Serd.jl** - Production-ready RDF serialization (RECOMMENDED)
2. **SPARQL.jl** - Experimental query generation (OPTIONAL)
3. **HTTP.jl** - Standard approach for SPARQL endpoints (RECOMMENDED)
4. **Catlab.jl** - Innovative category-theoretic alternative (EXPLORE LATER)

The commonly-assumed packages **Semantic.jl** and **RDFLib.jl do NOT exist** as RDF libraries.

=== Final Recommendation for Anamnesis

[IMPORTANT]
====
**Recommended Approach: Serd.jl + HTTP.jl + Virtuoso**

**Rationale**:

1. ‚úÖ **Adheres to NO PYTHON constraint**
2. ‚úÖ **Functional implementation possible** with existing packages
3. ‚úÖ **Performance-optimized** via Serd C library
4. ‚úÖ **Standards-compliant** SPARQL 1.1 protocol
5. ‚úÖ **Type-safe** Julia implementation
6. ‚úÖ **Academic rigor** supported by category theory alternative (Catlab.jl)
7. ‚úÖ **Maintainable** small codebase by known contributor

**Tradeoffs Accepted**:

* ‚ö†Ô∏è Less mature than Python/Java ecosystems
* ‚ö†Ô∏è More manual coding required (no high-level abstractions)
* ‚ö†Ô∏è Smaller community for support
* ‚ö†Ô∏è Limited reasoning capabilities (rely on Virtuoso or ŒªProlog)

**Why This Works**:

Anamnesis requires RDF *storage* and *querying*, not advanced reasoning. The Serd.jl + HTTP.jl combination provides sufficient capability for:

* Parsing multi-LLM conversations
* Generating RDF triples
* Storing in Virtuoso
* Querying with SPARQL
* Extracting bucketed knowledge

Advanced reasoning will be handled by ŒªProlog meta-reasoning layer, not RDF libraries.
====

=== Next Steps

1. ‚úÖ **Create Anamnesis repository** (DONE)
2. ‚úÖ **Research Julia RDF options** (THIS DOCUMENT)
3. ‚¨ú **Prototype**: Single conversation ‚Üí Virtuoso pipeline
4. ‚¨ú **Validate**: Query extracted knowledge via SPARQL
5. ‚¨ú **Iterate**: Expand to multi-LLM, cross-conversation linking
6. ‚¨ú **Optimize**: Profile and optimize if needed (consider ODBC)
7. ‚¨ú **Explore**: Catlab.jl for advanced reasoning (Phase 2)

== References

=== Packages

* Serd.jl: https://github.com/epatters/Serd.jl
* SPARQL.jl: https://github.com/epatters/SPARQL.jl
* RDF.jl: https://github.com/JuliaPackageMirrors/RDF.jl
* Catlab.jl: https://github.com/AlgebraicJulia/Catlab.jl
* HTTP.jl: https://github.com/JuliaWeb/HTTP.jl
* ODBC.jl: https://github.com/JuliaDatabases/ODBC.jl
* TypeDBClient.jl: https://github.com/Humans-of-Julia/TypeDBClient.jl
* SemanticModels.jl: https://github.com/jpfairbanks/SemanticModels.jl

=== Academic Papers

* Patterson, E., Lynch, O., & Fairbanks, J. (2022). "Categorical data structures for technical computing." *Compositionality*, 4, 5.
* Lambert, M., & Patterson, E. (2024). "Representing Knowledge and Querying Data using Double-Functorial Semantics." arXiv:2403.19884
* Patterson, E., et al. (2020). "Compositional Scientific Computing with Catlab and SemanticModels." arXiv:2005.04831

=== W3C Standards

* RDF 1.1 Concepts: https://www.w3.org/TR/rdf11-concepts/
* SPARQL 1.1 Query: https://www.w3.org/TR/sparql11-query/
* SPARQL 1.1 Protocol: https://www.w3.org/TR/sparql11-protocol/

=== Additional Resources

* AlgebraicJulia: https://www.algebraicjulia.org/
* Evan Patterson's Website: https://www.epatters.org/
* Julia Discourse (Data section): https://discourse.julialang.org/c/domain/data/
* Virtuoso Documentation: https://docs.openlinksw.com/virtuoso/

---

**Document Status**: ‚úÖ Research Complete +
**Date**: 2025-11-22 +
**Next Action**: Prototype implementation (Milestone 1)
